include "@zk-email/zk-regex-circom/circuits/regex_helpers.circom";

template ABRegex(msg_bytes) {
    signal input msg[msg_bytes];
    signal output out;

    var padded_msg_bytes = msg_bytes + 1;
    var num_state_trans = padded_msg_bytes + 1;
    signal in[padded_msg_bytes];
    in[0] <== 255;
    for (var i = 0; i < msg_bytes; i++) {
		in[i+1] <== msg[i];
	}

    var start_idx_var = 0;
    var end_idx_var = 0;
    var cur_state = 0;
    var is_moved = 0;
    var is_accepting = 0;
    var already_accepted = 0;


    for(var i = 0; i < padded_msg_bytes; i++) {
        if(already_accepted != 1 || is_accepting != 0) {
            is_moved = 0;
            if(cur_state == 0) {
                cur_state = in[i] == 97 ? 1 : cur_state;
                is_moved = in[i] == 97 ? 1 : is_moved;
            } else if(cur_state == 1) {
                cur_state = in[i] == 98 ? 2 : cur_state;
                is_moved = in[i] == 98 ? 1 : is_moved;
            }
            is_accepting = cur_state == 2 ? 1 : is_accepting;
            if(is_moved==1) {
                if(is_accepting == 1) {
                    end_idx_var = i+1;
                    if(already_accepted == 0 ) {
                        already_accepted = 1;
                    }
                }
            } else {
                cur_state = 0;
                if(already_accepted==0) {
                    start_idx_var = i+1;
                }
                if(is_accepting==1) {
                    is_accepting = 0;
                }
            }
        }
    }
    out <== 0;
}

component main = ABRegex(3);